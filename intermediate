Лексическое окружение - Создается в момент инициализации функции.

	Каждая функция при создании получает ссылку [[Scope]] на объект с переменными, в контексте которого была создана.
	При запуске функции создаётся новый объект с переменными LexicalEnvironment. Он получает ссылку на внешний объект переменных из [[Scope]].
	При поиске переменных он осуществляется сначала в текущем объекте переменных, а потом – по этой ссылке.

		2 типа -
	1) Внутреннее - Переменные которые лежат внутри функции
	2) В свойство [[Scope]] записывается ссылка на внешнее лексическое окружение (к примеру если функция лежит в глобале - запишется window)

 Замыкание это способ получения доступа и управления внешними переменными из функции.

	«Понимать замыкания» в JavaScript означает понимать следующие вещи:
	Все переменные и параметры функций являются свойствами объекта переменных LexicalEnvironment. Каждый запуск функции создаёт новый такой объект. На верхнем уровне им является «глобальный объект», в браузере – window.
	При создании функция получает системное свойство [[Scope]], которое ссылается на LexicalEnvironment, в котором она была создана.
	При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а затем во внешних LexicalEnvironment с места своего «рождения».

Прототипы - 
	Обратите внимание, что __proto__ — не то же самое, что [[Prototype]]. Это геттер/сеттер для него.
	Он существует по историческим причинам, в современном языке его заменяют функции Object.getPrototypeOf/Object.setPrototypeOf, которые также получают/устанавливают прототип. Мы рассмотрим причины этого и сами функции позже.
	Ссылки не могут идти по кругу. JavaScript выдаст ошибку, если мы попытаемся назначить __proto__ по кругу.
	Значение __proto__ может быть объектом или null. Другие типы игнорируются.

	Object.keys возвращает только собственные ключи
	for..in проходит и по своим, и по унаследованным ключам
	Почти все остальные методы получения ключей/значений игнорируют унаследованные свойства

	```
	В JavaScript все объекты имеют скрытое свойство [[Prototype]], которое является либо другим объектом, либо null.
	Мы можем использовать obj.__ proto__ для доступа к нему (исторически обусловленный геттер/сеттер, есть другие способы, которые скоро будут рассмотрены).
	Объект, на который ссылается [[Prototype]], называется «прототипом».
	Если мы хотим прочитать свойство obj или вызвать метод, которого не существует у obj, тогда JavaScript попытается найти его в прототипе.
	Операции записи/удаления работают непосредственно с объектом, они не используют прототип (если это обычное свойство, а не сеттер).
	Если мы вызываем obj.method(), а метод при этом взят из прототипа, то this всё равно ссылается на obj. Таким образом, методы всегда работают с текущим объектом, даже если они наследуются.
	Цикл for..in перебирает как свои, так и унаследованные свойства. Остальные методы получения ключей/значений работают только с собственными свойствами объекта.

	Свойство F.prototype (не путать с [[Prototype]]) устанавливает[[Prototype]] для новых объектов при вызове new F().	
	Значение F.prototype должно быть либо объектом, либо null. Другие значения не будут работать.
	Свойство "prototype" является особым, только когда оно назначено функции-конструктору, которая вызывается оператором new.
	
	В обычных объектах prototype не является чем-то особенным, считается обычным полем.

	По умолчанию все функции имеют F.prototype = { constructor: F }, поэтому мы можем получить конструктор объекта через свойство "constructor".
	```


Контекст
	Приоритет способов привязки this
	Когда интерпретатор пытается найти подходящий контекст выполнения для вызываемой функции, он проделывает следующую последовательность действий:

	Сначала проверяет, не вызвана ли функция как конструктор с ключевым словом new. В этом случае контекстом всегда будет пустой объект;
	Затем смотрит на фиксированные привязки (bind);
	Потом на явные привязки call или apply;
	После этого пытается неявно привязать к объекту, если функция вызвана как метод (через точку или квадратные скобки);
	Если и это не удается (обычный вызов функции), то в качестве контекста выполнения устанавливается глобальный объект (window) или undefined.

Задачки - https://jsfiddle.net/beuhzqas/1/






////////////////////////


1) Атрибуты, которые называются не так, как в html - className, htmlfor
2) В jsx даже если использовать что-то обернутое в script (с сервера пришло что-то типо script injection ), код внутри скрипта не выполнится.
3) Реакт смотрит на первую букву тега, чтобы узнать компонент ли это, либо обычный html тег
4) В ReactDOM.render нужно передавать react элемент <Element/>, а не компонент (const)
5) Если есть хотябы одна строка jsx кода - обязательно нужно импортировать React
6) setState - не всегда асинхронная функция (под капотом может отрендерить сначала тот компонент, который будет видео на экране и тд)
7) При setState - если функции сетСтейт нужно обновить состояние, основываясь на предыдущем состоянии, то нужно передать в аргументы сетСтейта state 
8) onSubmit формы отправляет юзера на новую страницу
9) preventDefault в form - отменит отрпавку данных на сервер и перезагрузку страницы
10) onChange лучше обновлять state, а state обновлять value элемента
11)
```
this.setState((state) => {return {...props}})
```
8) Если хотим поменять что-то в родительском компонента - можно передать функцию из него пропсами либо записать функцию в контекст
9) Ни в коем случае нельзя менять предыдущий стейт!


Prototype-
Методы задания прототипа - Object.setPrototypeOf(dog, animal) (ECMA 2015) лучше не использовать так как меняет реализацию движка
Чтобы у объекта не было прототипа - Object.create(null)

Ресурсы - bootwatch - bootstrap стили для приложения 
	  fownAwesome - пентограммы для иконок


js ---

1) Не все продвинутые функции fetch поддерживаются браузерами, но весь fetch полностью поддерживается любым браузером
2) Чтобы получить данные с сервера нужно 2 вызова (каждый вернет Promise) await fetch await.json, потом достать результат через then
3) Кроме .json() есть другие функции для других типов ответа: arrayBuffer(), blob(), text(), fromData()
4) Успешные ответы сервера это status 200-299
5) Regex101 - сайт помощник для создания регулярных выражений
6) loading.io - сайт с лоадерами 

Error boundary - компонент граница для componentDidCatch. Advanced фича реакт и появилась в react 16
Смысл - положить в стейт поле hasError или в этом роде. И в рендере сделать проверку на это поле, если true, то рендерить компонент ошибки

Паттерн рендерить в одном компоненте несколько списков (не только people or stars, а items)

Паттерн render-функции - передавать в компонент пропом функцию рендера, например 
```
renderItem = {(item) => (
<span>{item.name} <button>!</button></span>
)}
```
